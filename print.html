<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Java语言程序设计</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="前言.html">前言</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="编码风格.html"><strong aria-hidden="true">1.</strong> 编码风格</a></li><li class="chapter-item expanded "><a href="数据类型.html"><strong aria-hidden="true">2.</strong> 数据类型</a></li><li class="chapter-item expanded "><a href="运算符.html"><strong aria-hidden="true">3.</strong> 运算符</a></li><li class="chapter-item expanded "><a href="程序流程控制.html"><strong aria-hidden="true">4.</strong> 程序流程控制</a></li><li class="chapter-item expanded "><a href="数组.html"><strong aria-hidden="true">5.</strong> 数组</a></li><li class="chapter-item expanded "><a href="面向对象基础.html"><strong aria-hidden="true">6.</strong> 面向对象基础</a></li><li class="chapter-item expanded "><a href="面向对象进阶.html"><strong aria-hidden="true">7.</strong> 面向对象进阶</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Java语言程序设计</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<ul>
<li><a href="%E5%89%8D%E8%A8%80.html#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90">学习资源</a></li>
<li><a href="%E5%89%8D%E8%A8%80.html#window10%E5%AE%89%E8%A3%85jdk21%E5%B9%B6%E9%85%8D%E7%BD%AEeclipse">Window10安装jdk21并配置Eclipse</a>
<ul>
<li><a href="%E5%89%8D%E8%A8%80.html#jdk%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">JDK环境配置</a></li>
<li><a href="%E5%89%8D%E8%A8%80.html#%E7%94%A8eclipse%E5%86%99hello-world">用eclipse写hello world</a></li>
</ul>
</li>
</ul>
<h1 id="学习资源"><a class="header" href="#学习资源">学习资源</a></h1>
<p><a href="https://www.cnblogs.com/yupi/p/15166218.html">Java学习路线图</a></p>
<h1 id="window10安装jdk21并配置eclipse"><a class="header" href="#window10安装jdk21并配置eclipse">Window10安装jdk21并配置Eclipse</a></h1>
<p><a href="https://blog.csdn.net/weixin_50455331/article/details/126083021">JDK的环境配置（超详细教程）</a></p>
<p><a href="https://blog.csdn.net/weixin_50455331/article/details/126324741">eclipse下载与安装（汉化教程）超详细</a></p>
<p><a href="https://blog.csdn.net/qq_46110497/article/details/124607392">eclipse工具栏图标太小了，这样修改</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1795246">Eclipse 小技巧之设置 Java 代码自动提示和补全设置</a></p>
<h2 id="jdk环境配置"><a class="header" href="#jdk环境配置">JDK环境配置</a></h2>
<p>JDK环境配置是JDK安装过程中最为重要的内容，大多数初学者安装JDK最大的问题就是出在环境配置上面，所以这里我以windows 10为例，分享一下JDK环境配置的过程。</p>
<p>（PS：以下环境配置的标点符号是在英文状态下的）</p>
<p>1.点击 我的电脑 ——&gt; 右键 ——&gt; 选择属性 ，跳出如下图所示（windows 10系统），点击“高级系统设置”。或者 控制面板——&gt;系统和安全——&gt;系统   也可以找到“高级系统设置”。</p>
<p>2.跳出如下图所示内容，点击“系统环境变量”，</p>
<p>3.点击环境变量后，跳出如下图所示对话框，第一步点击 “新建”，随后跳出 “新建系统变量” 对话框，一般来说系统变量中是没有JAVA_HOME的，所以我们在弹出的“新建系统变量”对话框中的“变量名”填入 ：JAVA_HOME ，“变量值 ”填入 ：C:\Program Files\Java\jdk-12.0.1（安装Java时jdk 所在的文件夹，   默认安装都是在C盘的）。如果已经存在JAVA_HOME的，那么就在它的变量值的最后面加上分号（即；），然后再将 jdk 的路径添加在这个分号的后面。</p>
<p>注意：JAVA_HOME的变量值一定要进入到 jdk 所在的目录，然后再复制这个路径放进去。</p>
<p>4.新建变量名：CLASSPATH，变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar （注意前面的  .;  也要放进去）如下图：</p>
<p>注意：如果已经存在CLASSPATH，则在它的最前面或者最后面添加变量值，如果在最前面添加，应该先添加一个分号（即；），然后再在分号前面添加 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar （ .; 也要放进去）；如果在最后面添加，应该先添加一个分号（即；），然后再在分号后面添加  .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar （ .; 也要放进去）。</p>
<p>5.打开Path，点击新建按钮，添加变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin（注意：从分号分开作为两行）。</p>
<p>注意：在window 10系统中，配置JDK环境变量时，如果不将 Path 的 变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin 进行如下图这样配置，不分开两行，则会出错。但是如果你的系统是window 7的话，则可以不分开。</p>
<p>6.记得点击两次确定，如下图：</p>
<p>三. 验证JDK环境是否配置成功。</p>
<p>1.按住Window+R ，输入cmd，如下图：</p>
<p>2.回车，在cmd命令行分别输入java和javac（可以不区分大小写） ，出现如下图所示的画面而不是“javac不是内部变量……”即表示安装成功。</p>
<h2 id="用eclipse写hello-world"><a class="header" href="#用eclipse写hello-world">用eclipse写hello world</a></h2>
<p>1.新建一个Java project（Java项目）文件</p>
<p>选择File→new→java project</p>
<p>如果找不到java project ,可以先找到project…</p>
<p>然后在里面找到java project</p>
<p><img src="https://img-blog.csdnimg.cn/f492027ea5f9408fbfcab94d12c3cc31.png#pic_center" alt="a" /></p>
<p>2.在Project name（项目名称）里填入 Helloworld，然后点击finish （完成）会生成一个项目</p>
<p><img src="https://img-blog.csdnimg.cn/03ce6d3995b64b78b93d5332fc584cb0.png#pic_center" alt="a" /></p>
<p><img src="https://img-blog.csdnimg.cn/4237772d1a6e484f81e0e3e6fb7702a1.png#pic_center" alt="a" /></p>
<p>3.创建完项目后，右键Helloworld→new→Package（包），然后点击Finish会在Helloworld文件下生成一个包</p>
<p><img src="https://img-blog.csdnimg.cn/c9299c03023a450ea3c445c0035d5a1b.png#pic_center" alt="a" /></p>
<p><img src="https://img-blog.csdnimg.cn/f87db52076f34b58825d098d63893c4c.png#pic_center" alt="a" /></p>
<p>4.右键hello包（新生成的包）hello→new→Class (类)，新建一个类</p>
<p><img src="https://img-blog.csdnimg.cn/40b5a0cd4a5b47b085179d77f378b744.png#pic_center" alt="a" /></p>
<p>5.在生成的代码中的第七行填上下面这句代码：注意缩进</p>
<p><code>System.out.println(&quot;hello world&quot;)</code></p>
<p><img src="https://img-blog.csdnimg.cn/a32ea550651e4a9c96477f9d5a7d1bbe.png#pic_center" alt="a" /></p>
<p>6.点击运行之后会弹出一个新的窗口，点击OK</p>
<p><img src="https://img-blog.csdnimg.cn/0d3e4c3241ed4491aed820b13861da2d.png#pic_center" alt="a" /></p>
<p>底部控制台出现hello world 则表示运行成功</p>
<p><img src="https://img-blog.csdnimg.cn/7ef0afd6553445bca289ace49dbd0ed5.png#pic_center" alt="a" /></p>
<p>如果运行没有出任何问题的话，那么恭喜你，eclipse已经配置成功了。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="编码风格"><a class="header" href="#编码风格">编码风格</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h1>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">内置数据类型</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4">数值类型取值范围</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E7%B1%BB%E5%9E%8B%E9%BB%98%E8%AE%A4%E5%80%BC">类型默认值</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">引用类型</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E5%B8%B8%E9%87%8F">常量</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">自动类型转换</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">强制类型转换</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E9%9A%90%E5%90%AB%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">隐含强制类型转换</a></li>
</ul>
</li>
</ul>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p>
<p>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p>
<p>因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p>
<p>Java 有两大数据类型:</p>
<ul>
<li>内置数据类型</li>
<li>引用数据类型</li>
</ul>
<h2 id="内置数据类型"><a class="header" href="#内置数据类型">内置数据类型</a></h2>
<p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
<p>其中long型数据的&quot;L&quot;理论上不分大小写，但是若写成&quot;l&quot;容易与数字&quot;1&quot;混淆，不容易分辩。所以最好大写。</p>
<p><strong>浮点数比较不能用<code>==</code>！！！例如8.1/3和2.7。</strong></p>
<p>浮点数定义时可以省略一部分内容，但不能省略小数点。</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		float f1 = .0001f;
		float f2 = 1.0e-1f;
		double d = 1.;
		System.out.println(f1);
		System.out.println(f2);
		System.out.println(d);
	}
}
</code></pre>
<p>输出结果：</p>
<pre><code>1.0E-4
0.1
1.0
</code></pre>
<p><strong>字符型数据占16位</strong>。</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		char c = 'b' + 1;
		System.out.println(c); //c
		System.out.println((int)c); //99
		System.out.println((char)38889); //韩
	}
}
</code></pre>
<p>在Java中不能使用0表示false，也不能使用非0的整数表示true。</p>
<h3 id="数值类型取值范围"><a class="header" href="#数值类型取值范围">数值类型取值范围</a></h3>
<p>float数据类型精度7位，double数据类型精度11位。</p>
<p>对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。请看下面的例子：</p>
<pre><code class="language-java">public class PrimitiveTypeTest {  
    public static void main(String[] args) {  
        // byte  
        System.out.println(&quot;基本类型：byte 二进制位数：&quot; + Byte.SIZE);  
        System.out.println(&quot;包装类：java.lang.Byte&quot;);  
        System.out.println(&quot;最小值：Byte.MIN_VALUE=&quot; + Byte.MIN_VALUE);  
        System.out.println(&quot;最大值：Byte.MAX_VALUE=&quot; + Byte.MAX_VALUE);  
        System.out.println();  
  
        // short  
        System.out.println(&quot;基本类型：short 二进制位数：&quot; + Short.SIZE);  
        System.out.println(&quot;包装类：java.lang.Short&quot;);  
        System.out.println(&quot;最小值：Short.MIN_VALUE=&quot; + Short.MIN_VALUE);  
        System.out.println(&quot;最大值：Short.MAX_VALUE=&quot; + Short.MAX_VALUE);  
        System.out.println();  
  
        // int  
        System.out.println(&quot;基本类型：int 二进制位数：&quot; + Integer.SIZE);  
        System.out.println(&quot;包装类：java.lang.Integer&quot;);  
        System.out.println(&quot;最小值：Integer.MIN_VALUE=&quot; + Integer.MIN_VALUE);  
        System.out.println(&quot;最大值：Integer.MAX_VALUE=&quot; + Integer.MAX_VALUE);  
        System.out.println();  
  
        // long  
        System.out.println(&quot;基本类型：long 二进制位数：&quot; + Long.SIZE);  
        System.out.println(&quot;包装类：java.lang.Long&quot;);  
        System.out.println(&quot;最小值：Long.MIN_VALUE=&quot; + Long.MIN_VALUE);  
        System.out.println(&quot;最大值：Long.MAX_VALUE=&quot; + Long.MAX_VALUE);  
        System.out.println();  
  
        // float  
        System.out.println(&quot;基本类型：float 二进制位数：&quot; + Float.SIZE);  
        System.out.println(&quot;包装类：java.lang.Float&quot;);  
        System.out.println(&quot;最小值：Float.MIN_VALUE=&quot; + Float.MIN_VALUE);  
        System.out.println(&quot;最大值：Float.MAX_VALUE=&quot; + Float.MAX_VALUE);  
        System.out.println();  
  
        // double  
        System.out.println(&quot;基本类型：double 二进制位数：&quot; + Double.SIZE);  
        System.out.println(&quot;包装类：java.lang.Double&quot;);  
        System.out.println(&quot;最小值：Double.MIN_VALUE=&quot; + Double.MIN_VALUE);  
        System.out.println(&quot;最大值：Double.MAX_VALUE=&quot; + Double.MAX_VALUE);  
        System.out.println();  
  
        // char  
        System.out.println(&quot;基本类型：char 二进制位数：&quot; + Character.SIZE);  
        System.out.println(&quot;包装类：java.lang.Character&quot;);  
        // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台  
        System.out.println(&quot;最小值：Character.MIN_VALUE=&quot;  
                + (int) Character.MIN_VALUE);  
        // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台  
        System.out.println(&quot;最大值：Character.MAX_VALUE=&quot;  
                + (int) Character.MAX_VALUE);  
    }  
}
</code></pre>
<p>编译以上代码输出结果如下所示：</p>
<pre><code>基本类型：byte 二进制位数：8
包装类：java.lang.Byte
最小值：Byte.MIN_VALUE=-128
最大值：Byte.MAX_VALUE=127

基本类型：short 二进制位数：16
包装类：java.lang.Short
最小值：Short.MIN_VALUE=-32768
最大值：Short.MAX_VALUE=32767

基本类型：int 二进制位数：32
包装类：java.lang.Integer
最小值：Integer.MIN_VALUE=-2147483648
最大值：Integer.MAX_VALUE=2147483647

基本类型：long 二进制位数：64
包装类：java.lang.Long
最小值：Long.MIN_VALUE=-9223372036854775808
最大值：Long.MAX_VALUE=9223372036854775807

基本类型：float 二进制位数：32
包装类：java.lang.Float
最小值：Float.MIN_VALUE=1.4E-45
最大值：Float.MAX_VALUE=3.4028235E38

基本类型：double 二进制位数：64
包装类：java.lang.Double
最小值：Double.MIN_VALUE=4.9E-324
最大值：Double.MAX_VALUE=1.7976931348623157E308

基本类型：char 二进制位数：16
包装类：java.lang.Character
最小值：Character.MIN_VALUE=0
最大值：Character.MAX_VALUE=65535
</code></pre>
<p>float和double的最小值和最大值都是以科学记数法的形式输出的，结尾的&quot;E+数字&quot;表示E之前的数字要乘以10的多少次方。比如3.14E3就是3.14 × 10^3 =3140，3.14E-3 就是 3.14x10^{-3} =0.00314。</p>
<p>实际上，JAVA中还存在另外一种基本类型 void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。</p>
<h3 id="进制转换"><a class="header" href="#进制转换">进制转换</a></h3>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int num1 = 0b1010;
		int num2 = 01010;
		int num3 = 1010;
		int num4 = 0x1010;
		char c = '漢';
		
		System.out.println(&quot;num1 = &quot; + num1);
		System.out.println(&quot;num2 = &quot; + num2);
		System.out.println(&quot;num3 = &quot; + num3);
		System.out.println(&quot;num4 = &quot; + num4);
		System.out.println(&quot;漢的utf-8编码为： &quot; + (int)c);
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>num1 = 10
num2 = 520
num3 = 1010
num4 = 4112
漢的utf-8编码为： 28450
</code></pre>
<h3 id="类型默认值"><a class="header" href="#类型默认值">类型默认值</a></h3>
<p>下表列出了 Java 各个类型的默认值：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><strong>数据类型</strong></th><th style="text-align: left"><strong>默认值</strong></th></tr></thead><tbody>
<tr><td style="text-align: left">byte</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">short</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">int</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">long</td><td style="text-align: left">0L</td></tr>
<tr><td style="text-align: left">float</td><td style="text-align: left">0.0f</td></tr>
<tr><td style="text-align: left">double</td><td style="text-align: left">0.0d</td></tr>
<tr><td style="text-align: left">char</td><td style="text-align: left">'u0000'</td></tr>
<tr><td style="text-align: left">String (or any object)</td><td style="text-align: left">null</td></tr>
<tr><td style="text-align: left">boolean</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">测试示例：</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<pre><code class="language-java">public class Test {
    static boolean bool;
    static byte by;
    static char ch;
    static double d;
    static float f;
    static int i;
    static long l;
    static short sh;
    static String str;
 
    public static void main(String[] args) {
        System.out.println(&quot;Bool :&quot; + bool);
        System.out.println(&quot;Byte :&quot; + by);
        System.out.println(&quot;Character:&quot; + ch);
        System.out.println(&quot;Double :&quot; + d);
        System.out.println(&quot;Float :&quot; + f);
        System.out.println(&quot;Integer :&quot; + i);
        System.out.println(&quot;Long :&quot; + l);
        System.out.println(&quot;Short :&quot; + sh);
        System.out.println(&quot;String :&quot; + str);
    }
}
</code></pre>
<p>实例输出结果：</p>
<pre><code>Bool     :false
Byte     :0
Character:
Double   :0.0
Float    :0.0
Integer  :0
Long     :0
Short    :0
String   :null
</code></pre>
<h2 id="引用类型"><a class="header" href="#引用类型">引用类型</a></h2>
<p>引用类型主要包括类（class）、接口（interface）和数组。</p>
<ul>
<li>在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</li>
<li>对象、数组都是引用数据类型。</li>
<li>所有引用类型的默认值都是null。</li>
<li>一个引用变量可以用来引用任何与之兼容的类型。</li>
<li>例子：Site site = new Site(&quot;Runoob&quot;)。</li>
</ul>
<h2 id="常量"><a class="header" href="#常量">常量</a></h2>
<p>常量在程序运行时是不能被修改的。</p>
<p>在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：</p>
<pre><code class="language-java">final double PI = 3.1415927;
</code></pre>
<p>常量名虽然也可以用小写，但为了便于识别，通常使用大写字母表示常量。</p>
<p>字面量可以赋给任何内置类型的变量。例如：</p>
<pre><code class="language-java">byte a = 68;
char a = 'A'
</code></pre>
<p>byte、int、long和short都可以用十进制、16进制以及8进制的方式来表示。</p>
<p>当使用字面量的时候，前缀 0 表示 8 进制，而前缀 0x 代表 16 进制, 例如：</p>
<pre><code class="language-java">int decimal = 100;
int octal = 0144;
int hexa =  0x64;
</code></pre>
<p>和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列。下面是字符串型字面量的例子：</p>
<pre><code class="language-java">&quot;Hello World&quot;
&quot;two\nlines&quot;
&quot;\&quot;This is in quotes\&quot;&quot;
</code></pre>
<p>字符串常量和字符变量都可以包含任何 Unicode 字符。例如：</p>
<pre><code class="language-java">char a = '\u0001';
String a = &quot;\u0001&quot;;
</code></pre>
<p>Java语言支持一些特殊的转义字符序列。</p>
<div class="table-wrapper"><table><thead><tr><th>符号</th><th>字符含义</th></tr></thead><tbody>
<tr><td>\n</td><td>换行 (0x0a)</td></tr>
<tr><td>\r</td><td>回车 (0x0d)</td></tr>
<tr><td>\f</td><td>换页符(0x0c)</td></tr>
<tr><td>\b</td><td>退格 (0x08)</td></tr>
<tr><td>\0</td><td>空字符 (0x0)</td></tr>
<tr><td>\s</td><td>空格 (0x20)</td></tr>
<tr><td>\t</td><td>制表符</td></tr>
<tr><td>&quot;</td><td>双引号</td></tr>
<tr><td>'</td><td>单引号</td></tr>
<tr><td>\</td><td>反斜杠</td></tr>
<tr><td>\ddd</td><td>八进制字符 (ddd)</td></tr>
<tr><td>\uxxxx</td><td>16进制Unicode字符 (xxxx)</td></tr>
</tbody></table>
</div>
<h2 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h2>
<h3 id="自动类型转换"><a class="header" href="#自动类型转换">自动类型转换</a></h3>
<p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型（容量最大的那种类型），然后进行运算。</strong></p>
<p>转换从低级到高级顺序：</p>
<pre><code>低  ------------------------------------&gt;  高

byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 

</code></pre>
<p>（byte、short）和char之间赋值时不会发生自动类型转换，例如<code>byte b = 97;char c = b;</code>这种写法会报错。（byte、short）和char之间可以通过转换为int类型然后运算，例如<code>byte b = 97;short s = 10;short s2 = s + b;</code>也会报错。byte类型数据和byte类型数据之间运算结果也是int类型数据，例如<code>byte b1 = 97;byte b2 = 1;byte b = b1 + b2;</code>也会报错。</p>
<p><strong>自动类型转换必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</strong></p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		char c1='a';//定义一个char类型
        int i1 = c1;//char自动类型转换为int
        System.out.println(&quot;char自动类型转换为int后的值等于&quot;+i1);
        char c2 = 'A';//定义一个char类型
        int i2 = c2+1;//char 类型和 int 类型计算
        System.out.println(&quot;char类型和int计算后的值等于&quot;+i2);
	}

}
</code></pre>
<p>运行结果为：</p>
<pre><code>char自动类型转换为int后的值等于97
char类型和int计算后的值等于66
</code></pre>
<p>数据类型转换必须满足如下规则：</p>
<p>1.不能对boolean类型进行类型转换。</p>
<p>2.不能把对象类型转换成不相关类的对象。</p>
<p>3.<strong>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</strong></p>
<p>4.转换过程中可能导致溢出或损失精度，例如：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int i =128;   
		byte b = (byte)i;

		System.out.println(b);//输出-128
	}

}
</code></pre>
<p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p>
<p>5.<strong>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，也可以视为向零舍去</strong>，例如：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println((int)23.7 == 23);//true
		System.out.println((int)-45.89f == -45);//true
	}

}
</code></pre>
<h3 id="强制类型转换"><a class="header" href="#强制类型转换">强制类型转换</a></h3>
<p>定义语句<code>int n1 = 9L;</code>会报错，定义语句<code>float f = 1.1;</code>也会报错。</p>
<ul>
<li>
<ol>
<li>条件是转换的数据类型必须是兼容的。</li>
</ol>
</li>
<li>
<ol start="2">
<li>格式：(type)value中 type是要强制类型转换后的数据类型 </li>
</ol>
</li>
<li>3.强制转换符号只对最近的操作数有效，可以用小括号指定强制类型转换范围</li>
<li>4.char类型可以保存int类型常量值，但不能保存int类型变量值（此时需要强制类型转换）</li>
<li>5.byte、short、char类型数据参与运算时当作int类型处理</li>
</ul>
<p>基本数据类型和String类型的转换：</p>
<ul>
<li>基本数据类型转String类型：加“”即可</li>
<li>String类型转基本数据类型：根据基本数据类型的包装类调用parserXX方法即可，要获取特定字符可以使用字符串变量的charAt()方法</li>
</ul>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int num1 = 10;
		String s1 = num1 + &quot;&quot;;
		System.out.println(s1);
		
		String s2 = &quot;123&quot;;
		int num2 = Integer.parseInt(s2);
		System.out.println(num2);
		double num3 = Double.parseDouble(s2);
		System.out.println(num3);
		char c = s2.charAt(1);
		System.out.println(c);
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>10
123
123.0
2
</code></pre>
<h3 id="隐含强制类型转换"><a class="header" href="#隐含强制类型转换">隐含强制类型转换</a></h3>
<ul>
<li>1.整数的默认类型是 int。</li>
<li>2.小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f。</li>
</ul>
<p>涉及+号的数值类型转换，从左向右运算。如果+号左右两边都是数值类型则做加法运算；如果左右有一部分是字符串则作字符串拼接。</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println(100 + 98);
		System.out.println(&quot;100&quot; + 98);
		System.out.println(100 + 98 + &quot;hello&quot;);
		System.out.println(&quot;hello&quot; + 100 + 98);
	}
}
</code></pre>
<pre><code>198
10098
198hello
hello10098
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="java运算符"><a class="header" href="#java运算符">Java运算符</a></h1>
<ul>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">关系运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#instanceof-%E8%BF%90%E7%AE%97%E7%AC%A6">instanceof 运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6">条件运算符（?:）</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#java%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7">Java运算符优先级</a></li>
</ul>
<h2 id="概述-1"><a class="header" href="#概述-1">概述</a></h2>
<p>计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>位运算符</li>
<li>逻辑运算符</li>
<li>赋值运算符</li>
<li>其他运算符</li>
</ul>
<h2 id="算术运算符"><a class="header" href="#算术运算符">算术运算符</a></h2>
<p>算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算符。</p>
<p>表格中的实例假设整数变量A的值为10，变量B的值为20：</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody>
<tr><td>+</td><td>加法 - 相加运算符两侧的值</td><td>A + B 等于 30</td></tr>
<tr><td>-</td><td>减法 - 左操作数减去右操作数</td><td>A – B 等于 -10</td></tr>
<tr><td>*</td><td>乘法 - 相乘操作符两侧的值</td><td>A * B等于200</td></tr>
<tr><td>/</td><td>除法 - 左操作数除以右操作数</td><td>B / A等于2</td></tr>
<tr><td>％</td><td>取余 - 左操作数除以右操作数的余数</td><td>B%A等于0</td></tr>
<tr><td>++</td><td>自增: 操作数的值增加1</td><td>B++ 或 ++B 等于 21（区别详见下文）</td></tr>
<tr><td>--</td><td>自减: 操作数的值减少1</td><td>B-- 或 --B 等于 19（区别详见下文）</td></tr>
</tbody></table>
</div>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a = 10;
	    int b = 20;
	    int c = 25;
	    System.out.println(&quot;a + b = &quot; + (a + b) );
	    System.out.println(&quot;a - b = &quot; + (a - b) );
	    System.out.println(&quot;a * b = &quot; + (a * b) );
	    System.out.println(&quot;b / a = &quot; + (b / a) );
	    System.out.println(&quot;b % a = &quot; + (b % a) );
	    System.out.println(&quot;c % a = &quot; + (c % a) );
	    System.out.println(&quot;a++   = &quot; +  (a++) );
	    System.out.println(&quot;a--   = &quot; +  (a--) );
	    // 查看  d++ 与 ++d 的不同
	    int d = 25;
	    System.out.println(&quot;d++   = &quot; +  (d++) );
	    d = 25;
	    System.out.println(&quot;++d   = &quot; +  (++d) );
	}
}
</code></pre>
<pre><code>a + b = 30
a - b = -10
a * b = 200
b / a = 2
b % a = 0
c % a = 5
a++   = 10
a--   = 11
d++   = 25
++d   = 26
</code></pre>
<p><strong>自增自减运算符</strong></p>
<p><strong>1、自增（++）自减（--）运算符</strong>是一种特殊的算术运算符，在算术运算符中需要两个操作数来进行运算，而自增自减运算符是一个操作数。</p>
<p>2、前缀自增自减法(++a,--a): 先进行自增或者自减运算，再进行表达式运算。</p>
<p>3、后缀自增自减法(a++,a--): 先进行表达式运算，再进行自增或者自减运算。</p>
<p>典例：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int i = 10;
		i = i++;
		System.out.println(i);
		i = 10;
		i = ++i;
		System.out.println(i);
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>10
11
</code></pre>
<p>原因解释：</p>
<p>对于<code>i = i++;</code>这种自增运算需要一个临时变量temp，即（1）temp = i;（2）i = i + 1;（3）i = temp;第（1）步中的i是表达式右边的i，第（3）步中的i是表达式左边的i。</p>
<p>对于<code>i = ++i;</code>这种自增运算需要一个临时变量temp，即（1）i = i + 1;（2）temp = i;（3）i = temp;第（1）步中的i是表达式右边的i，第（3）步中的i是表达式左边的i。</p>
<h2 id="关系运算符"><a class="header" href="#关系运算符">关系运算符</a></h2>
<p>下表为Java支持的关系运算符</p>
<p>表格中的实例整数变量A的值为10，变量B的值为20：</p>
<div class="table-wrapper"><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th></tr></thead><tbody>
<tr><td>==</td><td>检查如果两个操作数的值是否相等，如果相等则条件为真。</td><td>（A == B）为假。</td></tr>
<tr><td>!=</td><td>检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td><td>(A != B) 为真。</td></tr>
<tr><td>&gt;</td><td>检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td><td>（A&gt; B）为假。</td></tr>
<tr><td>&lt;</td><td>检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td><td>（A &lt;B）为真。</td></tr>
<tr><td>&gt;=</td><td>检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td><td>（A&gt; = B）为假。</td></tr>
<tr><td>&lt;=</td><td>检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td><td>（A &lt;= B）为真。</td></tr>
<tr><td>实例：</td><td></td><td></td></tr>
</tbody></table>
</div>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a = 10;
	    int b = 20;
	    System.out.println(&quot;a == b = &quot; + (a == b) );
	    System.out.println(&quot;a != b = &quot; + (a != b) );
	    System.out.println(&quot;a &gt; b = &quot; + (a &gt; b) );
	    System.out.println(&quot;a &lt; b = &quot; + (a &lt; b) );
	    System.out.println(&quot;b &gt;= a = &quot; + (b &gt;= a) );
	    System.out.println(&quot;b &lt;= a = &quot; + (b &lt;= a) );
	}
}

</code></pre>
<p>输出结果如下：</p>
<pre><code>a == b = false
a != b = true
a &gt; b = false
a &lt; b = true
b &gt;= a = true
b &lt;= a = false
</code></pre>
<h2 id="instanceof-运算符"><a class="header" href="#instanceof-运算符">instanceof 运算符</a></h2>
<p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p>
<p>instanceof运算符使用格式如下：</p>
<pre><code class="language-java">( Object reference variable ) instanceof  (class/interface type)
</code></pre>
<p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。</p>
<p>下面是一个例子：</p>
<pre><code class="language-java">String name = &quot;James&quot;;
boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真
</code></pre>
<p>如果被比较的对象兼容于右侧类型，该运算符仍然返回 true。</p>
<p>看下面的例子：</p>
<pre><code class="language-java">class Vehicle {}
 
public class Car extends Vehicle {
   public static void main(String[] args){
      Vehicle a = new Car();
      boolean result =  a instanceof Car;
      System.out.println(result);
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>true
</code></pre>
<h2 id="位运算符"><a class="header" href="#位运算符">位运算符</a></h2>
<p>Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。</p>
<p>位运算符作用在所有的位上，并且按位运算。假设a = 60，b = 13;它们的二进制格式表示将如下：</p>
<pre><code class="language-java">A = 0011 1100
B = 0000 1101
-----------------
A&amp;B = 0000 1100
A | B = 0011 1101
A ^ B = 0011 0001
~A= 1100 0011
</code></pre>
<p>下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13：</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody>
<tr><td>＆</td><td>如果相对应位都是1，则结果为1，否则为0</td><td>（A＆B），得到12，即0000 1100</td></tr>
<tr><td>|</td><td>如果相对应位都是 0，则结果为 0，否则为 1</td><td>（A | B）得到61，即 0011 1101</td></tr>
<tr><td>^</td><td>如果相对应位值相同，则结果为0，否则为1</td><td>（A ^ B）得到49，即 0011 0001</td></tr>
<tr><td>〜</td><td>按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td><td>（〜A）得到-61，即1100 0011</td></tr>
<tr><td>&lt;&lt;</td><td>按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td>A &lt;&lt; 2得到240，即 1111 0000</td></tr>
<tr><td>&gt;&gt;</td><td>按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td>A &gt;&gt; 2得到15即 1111</td></tr>
<tr><td>&gt;&gt;&gt;</td><td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td>A&gt;&gt;&gt;2得到15即0000 1111</td></tr>
</tbody></table>
</div>
<p>实例：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a = 60; /* 60 = 0011 1100 */ 
	    int b = 13; /* 13 = 0000 1101 */
	    int c = 0;
	    c = a &amp; b;       /* 12 = 0000 1100 */
	    System.out.println(&quot;a &amp; b = &quot; + c );
	 
	    c = a | b;       /* 61 = 0011 1101 */
	    System.out.println(&quot;a | b = &quot; + c );
	 
	    c = a ^ b;       /* 49 = 0011 0001 */
	    System.out.println(&quot;a ^ b = &quot; + c );
	 
	    c = ~a;          /*-61 = 1100 0011 */
	    System.out.println(&quot;~a = &quot; + c );
	 
	    c = a &lt;&lt; 2;     /* 240 = 1111 0000 */
	    System.out.println(&quot;a &lt;&lt; 2 = &quot; + c );
	 
	    c = a &gt;&gt; 2;     /* 15 = 1111 */
	    System.out.println(&quot;a &gt;&gt; 2  = &quot; + c );
	  
	    c = a &gt;&gt;&gt; 2;     /* 15 = 0000 1111 */
	    System.out.println(&quot;a &gt;&gt;&gt; 2 = &quot; + c );
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>a &amp; b = 12
a | b = 61
a ^ b = 49
~a = -61
a &lt;&lt; 2 = 240
a &gt;&gt; 2  = 15
a &gt;&gt;&gt; 2 = 15
</code></pre>
<h2 id="逻辑运算符"><a class="header" href="#逻辑运算符">逻辑运算符</a></h2>
<p>下表列出了逻辑运算符的基本运算，假设布尔变量A为真，变量B为假</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody>
<tr><td>&amp;&amp;</td><td>称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td><td>（A &amp;&amp; B）为假。</td></tr>
<tr><td>| |</td><td>称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td><td>（A | | B）为真。</td></tr>
<tr><td>！</td><td>称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td><td>！（A &amp;&amp; B）为真。</td></tr>
<tr><td>下面的简单示例程序演示了逻辑运算符。</td><td></td><td></td></tr>
</tbody></table>
</div>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		boolean a = true;
	    boolean b = false;
	    System.out.println(&quot;a &amp;&amp; b = &quot; + (a&amp;&amp;b));
	    System.out.println(&quot;a || b = &quot; + (a||b) );
	    System.out.println(&quot;!(a &amp;&amp; b) = &quot; + !(a &amp;&amp; b));
	}
}

</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>a &amp;&amp; b = false
a || b = true
!(a &amp;&amp; b) = true
</code></pre>
<p><strong>短路逻辑运算符</strong></p>
<p>当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a = 5;//定义一个变量；
        boolean b = (a&lt;4)&amp;&amp;(a++&lt;10);
        System.out.println(&quot;使用短路逻辑运算符的结果为&quot;+b);
        System.out.println(&quot;a的结果为&quot;+a);
	}
}
</code></pre>
<pre><code>使用短路逻辑运算符的结果为false
a的结果为5
</code></pre>
<p><strong>解析：</strong> 该程序使用到了短路逻辑运算符(&amp;&amp;)，首先判断 a&lt;4 的结果为 false，则 b 的结果必定是 false，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。</p>
<p>位运算符也可以用在逻辑比较中。如下面例子所示：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int x = 5;
        int y = 5;
        if(x++ == 6 &amp; ++y == 6)//位运算 
        {
        	x = 11;
        }
        System.out.println(&quot;x = &quot; + x + &quot; y = &quot; + y );//6,6
        x = 5;
        y = 5;
        if(x++ == 6 &amp;&amp; ++y == 6) //逻辑与，短路运算
        {
        	x = 11;
        }
        System.out.println(&quot;x = &quot; + x + &quot; y = &quot; + y );//6,5
        x = 5;
        y = 5;
        if(x++ == 6 | ++y == 6)//位运算
        {
        	x = 11;
        }
        System.out.println(&quot;x = &quot; + x + &quot; y = &quot; + y );//11,6
        
        x = 5;
        y = 5;
        if(x++ == 6 || ++y == 6)//逻辑或，短路运算
        {
        	x = 11;
        }
        System.out.println(&quot;x = &quot; + x + &quot; y = &quot; + y );//11,5
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>x = 6 y = 6
x = 6 y = 5
x = 11 y = 6
x = 11 y = 6
</code></pre>
<h2 id="赋值运算符"><a class="header" href="#赋值运算符">赋值运算符</a></h2>
<p>下面是Java语言支持的赋值运算符：</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody>
<tr><td>=</td><td>简单的赋值运算符，将右操作数的值赋给左侧操作数</td><td>C = A + B将把A + B得到的值赋给C</td></tr>
<tr><td>+ =</td><td>加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td><td>C + = A等价于C = C + A</td></tr>
<tr><td>- =</td><td>减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td><td>C - = A等价于C = C - A</td></tr>
<tr><td>* =</td><td>乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td><td>C * = A等价于C = C * A</td></tr>
<tr><td>/ =</td><td>除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td><td>C / = A，C 与 A 同类型时等价于 C = C / A</td></tr>
<tr><td>（％）=</td><td>取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td><td>C％= A等价于C = C％A</td></tr>
<tr><td>&lt;&lt; =</td><td>左移位赋值运算符</td><td>C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td></tr>
<tr><td>&gt;&gt; =</td><td>右移位赋值运算符</td><td>C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td></tr>
<tr><td>＆=</td><td>按位与赋值运算符</td><td>C＆= 2等价于C = C＆2</td></tr>
<tr><td>^ =</td><td>按位异或赋值操作符</td><td>C ^ = 2等价于C = C ^ 2</td></tr>
<tr><td>| =</td><td>按位或赋值操作符</td><td>C | = 2等价于C = C | 2</td></tr>
</tbody></table>
</div>
<p>下面的简单示例程序演示了赋值运算符。</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a = 10;
        int b = 20;
        int c = 0;
        c = a + b;
        System.out.println(&quot;c = a + b = &quot; + c );
        c += a ;
        System.out.println(&quot;c += a  = &quot; + c );
        c -= a ;
        System.out.println(&quot;c -= a = &quot; + c );
        c *= a ;
        System.out.println(&quot;c *= a = &quot; + c );
        a = 10;
        c = 15;
        c /= a ;
        System.out.println(&quot;c /= a = &quot; + c );
        a = 10;
        c = 15;
        c %= a ;
        System.out.println(&quot;c %= a  = &quot; + c );
        c &lt;&lt;= 2 ;
        System.out.println(&quot;c &lt;&lt;= 2 = &quot; + c );
        c &gt;&gt;= 2 ;
        System.out.println(&quot;c &gt;&gt;= 2 = &quot; + c );
        c &gt;&gt;= 2 ;
        System.out.println(&quot;c &gt;&gt;= 2 = &quot; + c );
        c &amp;= a ;
        System.out.println(&quot;c &amp;= a  = &quot; + c );
        c ^= a ;
        System.out.println(&quot;c ^= a   = &quot; + c );
        c |= a ;
        System.out.println(&quot;c |= a   = &quot; + c );
	}
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>c = a + b = 30
c += a  = 40
c -= a = 30
c *= a = 300
c /= a = 1
c %= a  = 5
c &lt;&lt;= 2 = 20
c &gt;&gt;= 2 = 5
c &gt;&gt;= 2 = 1
c &amp;= a  = 0
c ^= a   = 10
c |= a   = 10
</code></pre>
<h2 id="条件运算符"><a class="header" href="#条件运算符">条件运算符（?:）</a></h2>
<p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p>
<pre><code class="language-java">variable x = (expression) ? value if true : value if false
</code></pre>
<p>实例</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a , b;
	    a = 10;
	    // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30
	    b = (a == 1) ? 20 : 30;
	    System.out.println( &quot;Value of b is : &quot; +  b );
	 
	    // 如果 a 等于 10 成立，则设置 b 为 20，否则为 30
	    b = (a == 10) ? 20 : 30;
	    System.out.println( &quot;Value of b is : &quot; + b );
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>Value of b is : 30
Value of b is : 20
</code></pre>
<h2 id="java运算符优先级"><a class="header" href="#java运算符优先级">Java运算符优先级</a></h2>
<p>当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。</p>
<p>例如，（1+3）＋（3+2）*2，这个表达式如果按加号最优先计算，答案就是 18，如果按照乘号最优先，答案则是 14。</p>
<p>再如，x = 7 + 3 * 2;这里x得到13，而不是20，因为乘法运算符比加法运算符有较高的优先级，所以先计算3 * 2得到6，然后再加7。</p>
<p>下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。</p>
<div class="table-wrapper"><table><thead><tr><th>类别</th><th>操作符</th><th>关联性</th></tr></thead><tbody>
<tr><td>后缀</td><td>() [] . (点操作符)</td><td>左到右</td></tr>
<tr><td>一元</td><td>expr++ expr--</td><td>从左到右</td></tr>
<tr><td>一元</td><td>++expr --expr + - ～ ！</td><td>从右到左</td></tr>
<tr><td>乘性</td><td>* /％</td><td>左到右</td></tr>
<tr><td>加性</td><td>+ -</td><td>左到右</td></tr>
<tr><td>移位</td><td>&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td><td>左到右</td></tr>
<tr><td>关系</td><td>&gt; &gt;= &lt; &lt;=</td><td>左到右</td></tr>
<tr><td>相等</td><td>==  !=</td><td>左到右</td></tr>
<tr><td>按位与</td><td>＆</td><td>左到右</td></tr>
<tr><td>按位异或</td><td>^</td><td>左到右</td></tr>
<tr><td>按位或</td><td>|</td><td>左到右</td></tr>
<tr><td>逻辑与</td><td>&amp;&amp;</td><td>左到右</td></tr>
<tr><td>逻辑或</td><td>| |</td><td>左到右</td></tr>
<tr><td>条件</td><td>？：</td><td>从右到左</td></tr>
<tr><td>赋值</td><td>= + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =</td><td>从右到左</td></tr>
<tr><td>逗号</td><td>，</td><td>左到右</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="程序流程控制"><a class="header" href="#程序流程控制">程序流程控制</a></h1>
<ul>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84">顺序结构</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84">条件结构</a>
<ul>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#if%E8%AF%AD%E5%8F%A5">if语句</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#ifelse%E8%AF%AD%E5%8F%A5">if...else语句</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#ifelse-ifelse-%E8%AF%AD%E5%8F%A5">if...else if...else 语句</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#%E5%B5%8C%E5%A5%97%E7%9A%84-ifelse-%E8%AF%AD%E5%8F%A5">嵌套的 if…else 语句</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#switch%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5">Switch分支语句</a></li>
</ul>
</li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84---for-while-%E5%8F%8A-dowhile">循环结构 - for, while 及 do...while</a>
<ul>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#while-%E5%BE%AA%E7%8E%AF">while 循环</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#dowhile-%E5%BE%AA%E7%8E%AF">do…while 循环</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#for%E5%BE%AA%E7%8E%AF">for循环</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#java-%E5%A2%9E%E5%BC%BA-for-%E5%BE%AA%E7%8E%AF">Java 增强 for 循环</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6">多重循环控制</a></li>
</ul>
</li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#break-%E5%85%B3%E9%94%AE%E5%AD%97">break 关键字</a>
<ul>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#%E8%AF%AD%E6%B3%95">语法</a></li>
</ul>
</li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#continue-%E5%85%B3%E9%94%AE%E5%AD%97">continue 关键字</a>
<ul>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#%E8%AF%AD%E6%B3%95-1">语法</a></li>
</ul>
</li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#return%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">return跳转控制语句</a></li>
</ul>
<h2 id="顺序结构"><a class="header" href="#顺序结构">顺序结构</a></h2>
<p>逐条执行语句</p>
<h2 id="条件结构"><a class="header" href="#条件结构">条件结构</a></h2>
<p>Java 中的条件语句允许程序根据条件的不同执行不同的代码块。</p>
<p>一个 if 语句包含一个布尔表达式和一条或多条语句。</p>
<h3 id="if语句"><a class="header" href="#if语句">if语句</a></h3>
<p>if 语句的语法如下：</p>
<pre><code class="language-java">if(布尔表达式)
{
   //如果布尔表达式为true将执行的语句
}
</code></pre>
<p>如果布尔表达式的值为 true，则执行 if 语句中的代码块，否则执行 else 语句块后面的代码。</p>
<p>实例：</p>
<pre><code class="language-java">public class Test {
 
   public static void main(String args[]){
      int x = 10;
 
      if( x &lt; 20 ){
         System.out.print(&quot;这是 if 语句&quot;);
      }
   }
}
</code></pre>
<p>以上代码编译运行结果如下：</p>
<pre><code>这是 if 语句
</code></pre>
<h3 id="ifelse语句"><a class="header" href="#ifelse语句">if...else语句</a></h3>
<p>if 语句后面可以跟 else 语句，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行。</p>
<p>if…else 的用法如下：</p>
<pre><code class="language-java">if(布尔表达式){
   //如果布尔表达式的值为true
}else{
   //如果布尔表达式的值为false
}
</code></pre>
<p>实例：</p>
<pre><code class="language-java">public class Test {
 
   public static void main(String args[]){
      int x = 30;
 
      if( x &lt; 20 ){
         System.out.print(&quot;这是 if 语句&quot;);
      }else{
         System.out.print(&quot;这是 else 语句&quot;);
      }
   }
}
</code></pre>
<p>以上代码编译运行结果如下：</p>
<pre><code>这是 else 语句
</code></pre>
<h3 id="ifelse-ifelse-语句"><a class="header" href="#ifelse-ifelse-语句">if...else if...else 语句</a></h3>
<p>if 语句后面可以跟 else if…else 语句，这种语句可以检测到多种可能的情况。</p>
<p>使用 if，else if，else 语句的时候，需要注意下面几点：</p>
<ul>
<li>if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。</li>
<li>if 语句可以有若干个 else if 语句，它们必须在 else 语句之前。</li>
<li>一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。</li>
</ul>
<p>if...else 语法格式如下:</p>
<pre><code class="language-java">if(布尔表达式 1){
   //如果布尔表达式 1的值为true执行代码
}else if(布尔表达式 2){
   //如果布尔表达式 2的值为true执行代码
}else if(布尔表达式 3){
   //如果布尔表达式 3的值为true执行代码
}else {
   //如果以上布尔表达式都不为true执行代码
}
</code></pre>
<p>实例：</p>
<pre><code class="language-java">public class Test {
   public static void main(String args[]){
      int x = 30;
 
      if( x == 10 ){
         System.out.print(&quot;Value of X is 10&quot;);
      }else if( x == 20 ){
         System.out.print(&quot;Value of X is 20&quot;);
      }else if( x == 30 ){
         System.out.print(&quot;Value of X is 30&quot;);
      }else{
         System.out.print(&quot;这是 else 语句&quot;);
      }
   }
}
</code></pre>
<p>以上代码编译运行结果如下：</p>
<pre><code>Value of X is 30
</code></pre>
<p>如果条件表达式写成了赋值运算符，则会发生如下情况：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int k;
		boolean b = true;
		if(b=false)
			System.out.println(k=1);
		else if(b){
			System.out.println(k=2);
		}
		else if(!b){
			System.out.println(k=3);
		}
		else {
			System.out.println(k=4);
		}
	}
}
</code></pre>
<p>输出结果为3</p>
<p>原因解释：<code>b=false</code>使得b变为false，第一个和第二个分支的条件表达式结果均为假。</p>
<h3 id="嵌套的-ifelse-语句"><a class="header" href="#嵌套的-ifelse-语句">嵌套的 if…else 语句</a></h3>
<p>使用嵌套的 if…else 语句是合法的。也就是说你可以在另一个 if 或者 else if 语句中使用 if 或者 else if 语句。</p>
<p>嵌套的 if…else 语法格式如下：</p>
<pre><code class="language-java">if(布尔表达式 1){
   ////如果布尔表达式 1的值为true执行代码
   if(布尔表达式 2){
      ////如果布尔表达式 2的值为true执行代码
   }
}
</code></pre>
<p>你可以像 if 语句一样嵌套 else if...else。</p>
<p>实例：</p>
<pre><code class="language-java">import java.util.Scanner;

public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		Scanner scanner = new Scanner(System.in);
		System.out.println(&quot;Please input your score:&quot;);
		double score = scanner.nextDouble();
		if(score &gt;= 8.0){
			System.out.println(&quot;Please input your gender:&quot;);
			char gender = scanner.next().charAt(0); 
			if(gender == '男'){
				System.out.println(&quot;Succeed to join men's group!&quot;);
			}
			else if(gender == '女'){
				System.out.println(&quot;Succeed to join women's group!&quot;);
			}
			else {
				System.out.println(&quot;You inputed the wrong gender!&quot;);
			}
		}
		else {
			System.out.println(&quot;You are fired!&quot;);
		}
		scanner.close();
	}
}
</code></pre>
<p>以上代码编译运行结果如下：</p>
<pre><code>Please input your score:
9
Please input your gender:
0
You inputed the wrong gender!
</code></pre>
<h3 id="switch分支语句"><a class="header" href="#switch分支语句">Switch分支语句</a></h3>
<p>switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>
<p>switch case 语句语法格式如下：</p>
<pre><code class="language-java">switch(expression){
    case value :
       //语句
       break; //可选
    case value :
       //语句
       break; //可选
    //你可以有任意数量的case语句
    default : //可选
       //语句
}
</code></pre>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/09/java-switch-case-flow-diagram.jpeg" alt="a" /></p>
<p>switch case 语句有如下规则：</p>
<ul>
<li>switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。也可以是由enum类型，但不能是double或float类型。</li>
<li>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。</li>
<li><strong>case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量</strong>。</li>
<li>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。</li>
<li>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。</li>
<li>switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。</li>
</ul>
<p><strong>switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。</strong></p>
<pre><code class="language-java">package struct;

public class SwitchDemo1 {

    public static void main(String[] args) {
        char grade = 'C';

        switch(grade){
            case 'A':
                System.out.println(&quot;优秀&quot;);
                break;
            case 'B':
                System.out.println(&quot;良好&quot;);
                break;
            case 'C':
                System.out.println(&quot;及格&quot;);
                break;
            case 'D':
                System.out.println(&quot;再接再厉&quot;);
                break;
            case 'E':
                System.out.println(&quot;挂科&quot;);
                break;
            default:
                System.out.println(&quot;未知等级&quot;);

                //存在case穿透现象，每写一个case就要添加一个break语句

        }
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code>良好
你的等级是 C
</code></pre>
<p>如果 case 语句块中没有 break 语句时，JVM 并不会顺序输出每一个 case 对应的返回值，而是继续匹配，匹配不成功则返回默认 case。</p>
<p>Test.java实例：</p>
<pre><code class="language-java">public class Test {
   public static void main(String args[]){
      int i = 5;
      switch(i){
         case 0:
            System.out.println(&quot;0&quot;);
         case 1:
            System.out.println(&quot;1&quot;);
         case 2:
            System.out.println(&quot;2&quot;);
         default:
            System.out.println(&quot;default&quot;);
      }
   }
}
</code></pre>
<p>以上代码编译运行结果如下：</p>
<pre><code>default
</code></pre>
<p>如果 case 语句块中没有 break 语句时，匹配成功后，从当前 case 开始，后续所有 case 的值都会输出。</p>
<p>Test.java 文件代码：</p>
<pre><code class="language-java">public class Test {
   public static void main(String args[]){
      int i = 1;
      switch(i){
         case 0:
            System.out.println(&quot;0&quot;);
         case 1:
            System.out.println(&quot;1&quot;);
         case 2:
            System.out.println(&quot;2&quot;);
         default:
            System.out.println(&quot;default&quot;);
      }
   }
}
</code></pre>
<p>以上代码编译运行结果如下：</p>
<pre><code>1
2
default
</code></pre>
<p>如果当前匹配成功的 case 语句块没有 break 语句，则从当前 case 开始，后续所有 case 的值都会输出，如果后续的 case 语句块有 break 语句则会跳出判断。</p>
<p>Test.java 文件代码：</p>
<pre><code class="language-java">public class Test {
   public static void main(String args[]){
      int i = 1;
      switch(i){
         case 0:
            System.out.println(&quot;0&quot;);
         case 1:
            System.out.println(&quot;1&quot;);
         case 2:
            System.out.println(&quot;2&quot;);
         case 3:
            System.out.println(&quot;3&quot;); break;
         default:
            System.out.println(&quot;default&quot;);
      }
   }
}
</code></pre>
<p>以上代码编译运行结果如下：</p>
<pre><code class="language-txt">1
2
3
</code></pre>
<p>使用字符串类型数据的switch语句实例：</p>
<pre><code class="language-java">package struct;

public class SwitchDemo2 {
    public static void main(String[] args) {
        String name= &quot;狂神&quot;;

        switch (name){
            case &quot;包子&quot;:
                System.out.println(&quot;包子&quot;);
            case &quot;狂神&quot;:
                System.out.println(&quot;狂神&quot;);
                break;
            default:
                System.out.println(&quot;输错了&quot;);

        }
    }
}
</code></pre>
<h2 id="循环结构---for-while-及-dowhile"><a class="header" href="#循环结构---for-while-及-dowhile">循环结构 - for, while 及 do...while</a></h2>
<p>顺序结构的程序语句只能被执行一次。</p>
<p>如果您想要同样的操作执行多次，就需要使用循环结构。</p>
<p>Java中有三种主要的循环结构：</p>
<ul>
<li><strong>while</strong> 循环</li>
<li><strong>do…while</strong> 循环</li>
<li><strong>for</strong> 循环</li>
</ul>
<p>在 Java5 中引入了一种主要用于数组的增强型 for 循环。</p>
<h3 id="while-循环"><a class="header" href="#while-循环">while 循环</a></h3>
<p>while是最基本的循环，它的结构为：</p>
<pre><code class="language-java">while( 布尔表达式 ) {
  //循环内容
}
</code></pre>
<p>只要布尔表达式为 true，循环就会一直执行下去。</p>
<p>实例Test.java 文件代码：</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      int x = 10;
      while( x &lt; 20 ) {
         System.out.print(&quot;value of x : &quot; + x );
         x++;
         System.out.print(&quot;\n&quot;);
      }
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>value of x : 10
value of x : 11
value of x : 12
value of x : 13
value of x : 14
value of x : 15
value of x : 16
value of x : 17
value of x : 18
value of x : 19
</code></pre>
<h3 id="dowhile-循环"><a class="header" href="#dowhile-循环">do…while 循环</a></h3>
<p>对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p>
<p>do…while 循环和 while 循环相似，不同的是，<strong>do…while 循环至少会执行一次</strong>。</p>
<pre><code class="language-java">do {
       //代码语句
}while(布尔表达式);
</code></pre>
<p><strong>注意：</strong> 布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。</p>
<p>实例Test.java 文件代码：</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args){
      int x = 10;
 
      do{
         System.out.print(&quot;value of x : &quot; + x );
         x++;
         System.out.print(&quot;\n&quot;);
      }while( x &lt; 20 );
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>value of x : 10
value of x : 11
value of x : 12
value of x : 13
value of x : 14
value of x : 15
value of x : 16
value of x : 17
value of x : 18
value of x : 19
</code></pre>
<h3 id="for循环"><a class="header" href="#for循环">for循环</a></h3>
<p>虽然所有循环结构都可以用 while 或者 do...while表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。</p>
<p>for循环执行的次数是在执行前就确定的。语法格式如下：</p>
<pre><code class="language-java">for(初始化; 布尔表达式; 更新) {
    //代码语句
}
</code></pre>
<p>关于 for 循环有以下几点说明：</p>
<ul>
<li>最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</li>
<li>然后，<strong>检测布尔表达式的值，该表达式的值只能是true或false</strong>。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</li>
<li>执行一次循环后，更新循环控制变量。</li>
<li>再次检测布尔表达式。循环执行上面的过程。</li>
</ul>
<p>实例代码：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		for(int x = 10, y = 0; x &lt; 15; x = x+1, y++) {
	         System.out.println(&quot;value of x : &quot; + x );
	         System.out.println(&quot;value of y : &quot; + y );
	      }
	}
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>value of x : 10
value of y : 0
value of x : 11
value of y : 1
value of x : 12
value of y : 2
value of x : 13
value of y : 3
value of x : 14
value of y : 4
</code></pre>
<p>下面这种写法为死循环：</p>
<pre><code class="language-java">for(;;)
{
	System.out.println(&quot;香水有毒！&quot;);
}
</code></pre>
<h3 id="java-增强-for-循环"><a class="header" href="#java-增强-for-循环">Java 增强 for 循环</a></h3>
<p>Java5 引入了一种主要用于数组的增强型 for 循环。</p>
<p>Java 增强 for 循环语法格式如下:</p>
<pre><code class="language-java">for(声明语句 : 表达式)
{
   //代码句子
}
</code></pre>
<p><strong>声明语句：</strong> 声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p>
<p><strong>表达式：</strong> 表达式是要访问的数组名，或者是返回值为数组的方法。</p>
<p>实例：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		int [] numbers = {10, 20, 30, 40, 50};
		 
	    for(int x : numbers ){
	       System.out.print( x );
	       System.out.print(&quot;,&quot;);
	    }
	    System.out.print(&quot;\n&quot;);
	    String [] names ={&quot;James&quot;, &quot;Larry&quot;, &quot;Tom&quot;, &quot;Lacy&quot;};
	    for( String name : names ) {
	       System.out.print( name );
	       System.out.print(&quot;,&quot;);
	    }
	}
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>10,20,30,40,50,
James,Larry,Tom,Lacy,
</code></pre>
<h3 id="多重循环控制"><a class="header" href="#多重循环控制">多重循环控制</a></h3>
<p>练习：打印九九乘法表</p>
<pre><code class="language-java">package struct;

public class ForDemo2 {
    public static void main(String[] args) {
        for (int i = 1; i &lt; 10; i++) {
            for(int j =1; j&lt;=i;j++){
                System.out.print(&quot;&quot;+j+'*'+i+'='+(i*j)+&quot;\t&quot;);
            }
            System.out.println();
        }
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">1*1=1	
1*2=2	2*2=4	
1*3=3	2*3=6	3*3=9	
1*4=4	2*4=8	3*4=12	4*4=16	
1*5=5	2*5=10	3*5=15	4*5=20	5*5=25	
1*6=6	2*6=12	3*6=18	4*6=24	5*6=30	6*6=36	
1*7=7	2*7=14	3*7=21	4*7=28	5*7=35	6*7=42	7*7=49	
1*8=8	2*8=16	3*8=24	4*8=32	5*8=40	6*8=48	7*8=56	8*8=64	
1*9=9	2*9=18	3*9=27	4*9=36	5*9=45	6*9=54	7*9=63	8*9=72	9*9=81	
</code></pre>
<p>练习：输出三角形</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int n = 5;
		for(int i = 1; i &lt;= n; i++){  //i代表层数
			
			for(int j = 0; j &lt; n - i; j++){
				
				System.out.print(' ');
				
			}
			for(int j = 0; j &lt; 2 * i - 1; j++){ //每行打印2*i-1个*
							
				System.out.print('*');
					
			}
			System.out.print('\n');
		}
	}
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">     *
    ***
   *****
  *******
 *********
</code></pre>
<p>练习：打印空心三角形</p>
<p>自己实现版本：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int n = 5;
		for(int j = n; j &gt;= 2; j--){
			
			for(int i = 1; i &lt;= 2 * n; i++){
				
				if(i == j || i + j == 2 * n){
					System.out.print('*');
				}
				else {
					System.out.print(' ');
				}
			}
			System.out.print('\n');
		}
		for(int i = 0; i &lt; 2 * n - 1; i++) {
			System.out.print('*');
		}
	}
}
</code></pre>
<p>课堂版本：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int n = 5;
		for(int i = 1; i &lt;= n; i++){  //i代表层数
			
			for(int j = 0; j &lt; n - i; j++){
				
				System.out.print(' ');
				
			}
			for(int j = 1; j &lt;= 2 * i - 1; j++){
							
				if(j == 1 || j == 2 * i - 1 || i == n) {
					System.out.print('*');
				}
				else {
					System.out.print(' ');
				}
					
			}
			System.out.print('\n');
		}
	}
}
</code></pre>
<p>输出结果：</p>
<pre><code>    *     
   * *    
  *   *   
 *     *  
*********
</code></pre>
<hr />
<h2 id="break-关键字"><a class="header" href="#break-关键字">break 关键字</a></h2>
<p>break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。</p>
<p>break 跳出最里层的循环，并且继续执行该循环下面的语句。</p>
<p><strong>break语句出现在多层嵌套的语句块中时，可以通过标签指定要终止的是哪一层语句块。但在开发中尽量不要使用标签，无标签时默认跳出最近的循环体。</strong></p>
<h3 id="语法"><a class="header" href="#语法">语法</a></h3>
<p>break 的用法很简单，就是循环结构中的一条语句：</p>
<pre><code>break;
</code></pre>
<p>实例Test.java 文件代码：</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      int [] numbers = {10, 20, 30, 40, 50};
 
      for(int x : numbers ) {
         // x 等于 30 时跳出循环
         if( x == 30 ) {
            break;
         }
         System.out.print( x );
         System.out.print(&quot;\n&quot;);
      }
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>10
20
</code></pre>
<p>使用标签的的循环体程序：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int n = 10;
		label2222221:
		for(int i = 1; i &lt;= n; i++){  //i代表层数
			
			for(int j = 0; j &lt; n - i; j++){
				
				System.out.print(' ');
				
			}
			for(int j = 1; j &lt;= 2 * i - 1; j++){
							
				if(j == 1 || j == 2 * i - 1 || i == n) {
					System.out.print('*');
				}
				else {
					System.out.print(' ');
					break label2222221;
				}
					
			}
			System.out.print('\n');
		}
	}
}
</code></pre>
<hr />
<h2 id="continue-关键字"><a class="header" href="#continue-关键字">continue 关键字</a></h2>
<p>continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。</p>
<p>在 for 循环中，continue 语句使程序立即跳转到更新语句。</p>
<p>在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。</p>
<p><strong>continue语句出现在多层嵌套的语句块中时，可以通过标签指定要终止的是哪一层语句块。但在开发中尽量不要使用标签，无标签时默认再次进入最近的循环体。</strong></p>
<h3 id="语法-1"><a class="header" href="#语法-1">语法</a></h3>
<p>continue 就是循环体中一条简单的语句：</p>
<pre><code>continue;
</code></pre>
<p>实例Test.java 文件代码：</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      int [] numbers = {10, 20, 30, 40, 50};
 
      for(int x : numbers ) {
         if( x == 30 ) {
        continue;
         }
         System.out.print( x );
         System.out.print(&quot;\n&quot;);
      }
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>10
20
40
50
</code></pre>
<h2 id="return跳转控制语句"><a class="header" href="#return跳转控制语句">return跳转控制语句</a></h2>
<p>return能中止普通方法的执行，也能通过main方法终止程序的执行。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<ul>
<li><a href="%E6%95%B0%E7%BB%84.html#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="%E6%95%B0%E7%BB%84.html#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F">声明数组变量</a></li>
<li><a href="%E6%95%B0%E7%BB%84.html#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84">创建数组</a></li>
<li><a href="%E6%95%B0%E7%BB%84.html#%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84">处理数组</a></li>
<li><a href="%E6%95%B0%E7%BB%84.html#for-each-%E5%BE%AA%E7%8E%AF">For-Each 循环</a></li>
<li><a href="%E6%95%B0%E7%BB%84.html#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0">数组作为函数的参数</a></li>
<li><a href="%E6%95%B0%E7%BB%84.html#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">数组作为函数的返回值</a></li>
<li><a href="%E6%95%B0%E7%BB%84.html#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">多维数组</a>
<ul>
<li><a href="%E6%95%B0%E7%BB%84.html#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%BA%E4%BE%8B">多维数组的动态初始化（以二维数组为例）</a></li>
<li><a href="%E6%95%B0%E7%BB%84.html#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8%E4%BB%A5%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%BA%E4%BE%8B">多维数组的引用（以二维数组为例）</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E7%BB%84.html#arrays-%E7%B1%BB">Arrays 类</a></li>
</ul>
<h2 id="概述-2"><a class="header" href="#概述-2">概述</a></h2>
<p>数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。</p>
<p>Java 语言中提供的数组是用来存储固定大小的同类型元素。</p>
<p>你可以声明一个数组变量，如 <code>numbers[100]</code> 来代替直接声明 100 个独立变量 number0，number1，....，number99。</p>
<p>本教程将为大家介绍 Java 数组的声明、创建和初始化，并给出其对应的代码。</p>
<h2 id="声明数组变量"><a class="header" href="#声明数组变量">声明数组变量</a></h2>
<p>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</p>
<pre><code class="language-java">dataType[] arrayRefVar;   // 首选的方法
 
或
 
dataType arrayRefVar[];  // 效果相同，但不是首选方法
</code></pre>
<p><strong>注意:</strong> 建议使用 <strong>dataType[] arrayRefVar</strong> 的声明风格声明数组变量。 dataType arrayRefVar[] 风格是来自 C/C++ 语言 ，在Java中采用是为了让 C/C++ 程序员能够快速理解java语言。</p>
<p>下面是这两种语法的代码示例：</p>
<pre><code class="language-java">double[] myList;         // 首选的方法
 
或
 
double myList[];         //  效果相同，但不是首选方法
</code></pre>
<hr />
<h2 id="创建数组"><a class="header" href="#创建数组">创建数组</a></h2>
<p>Java语言使用new操作符来创建数组，语法如下：</p>
<pre><code class="language-java">arrayRefVar = new dataType[arraySize];
</code></pre>
<p>上面的语法语句做了两件事：</p>
<ul>
<li>一、使用 <code>dataType[arraySize]</code> 创建了一个数组。</li>
<li>二、把新创建的数组的引用赋值给变量 arrayRefVar。</li>
</ul>
<p>数组变量的声明，和创建数组可以用一条语句完成，如下所示：</p>
<pre><code class="language-java">dataType[] arrayRefVar = new dataType[arraySize];
</code></pre>
<p>另外，你还可以使用如下的方式创建数组。</p>
<pre><code class="language-java">dataType[] arrayRefVar = {value0, value1, ..., valuek};
</code></pre>
<p><strong>数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。</strong></p>
<p>数组创建后如果没有赋值，有默认值：</p>
<p>int 0，short 0，byte 0，long 0，float 0.0， double 0.0，char <code>\u0000</code>，
boolean false， String null</p>
<p>数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1。</p>
<p>下面的语句首先声明了一个数组变量 myList，接着创建了一个包含 10 个 double 类型元素的数组，并且把它的引用赋值给 myList 变量。</p>
<pre><code class="language-java">public class TestArray {
   public static void main(String[] args) {
      // 数组大小
      int size = 10;
      // 定义数组
      double[] myList = new double[size];
      myList[0] = 5.6;
      myList[1] = 4.5;
      myList[2] = 3.3;
      myList[3] = 13.2;
      myList[4] = 4.0;
      myList[5] = 34.33;
      myList[6] = 34.0;
      myList[7] = 45.45;
      myList[8] = 99.993;
      myList[9] = 11123;
      // 计算所有元素的总和
      double total = 0;
      for (int i = 0; i &lt; size; i++) {
         total += myList[i];
      }
      System.out.println(&quot;总和为： &quot; + total);
   }
}
</code></pre>
<p>以上实例输出结果为：</p>
<pre><code>总和为： 11367.373
</code></pre>
<p>下面的图片描绘了数组 myList。这里 myList 数组里有 10 个 double 元素，它的下标从 0 到 9。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/12-130Q0221Q5602.jpg" alt="java数组结构说明" /></p>
<hr />
<h2 id="处理数组"><a class="header" href="#处理数组">处理数组</a></h2>
<p><strong>数组赋值机制：数组在默认情况下是引用传递（地址传递）而不是值传递，赋的值是地址</strong></p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] arr1 = {1,2,3,4};
		int[] arr2 = arr1;
		arr1[2] = 6;
		for(int i = 0; i &lt; arr2.length; i++) {
			System.out.println(arr2[i]);
		}
	}
}

</code></pre>
<p>输出结果如下：</p>
<pre><code>1
2
6
4
</code></pre>
<p>数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 For-Each 循环。</p>
<p>该实例完整地展示了如何创建、初始化和操纵数组：</p>
<pre><code class="language-java">public class TestArray {
   public static void main(String[] args) {
      double[] myList = {1.9, 2.9, 3.4, 3.5};
 
      // 打印所有数组元素
      for (int i = 0; i &lt; myList.length; i++) {
         System.out.println(myList[i] + &quot; &quot;);
      }
      // 计算所有元素的总和
      double total = 0;
      for (int i = 0; i &lt; myList.length; i++) {
         total += myList[i];
      }
      System.out.println(&quot;Total is &quot; + total);
      // 查找最大元素
      double max = myList[0];
      for (int i = 1; i &lt; myList.length; i++) {
         if (myList[i] &gt; max) max = myList[i];
      }
      System.out.println(&quot;Max is &quot; + max);
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>1.9
2.9
3.4
3.5
Total is 11.7
Max is 3.5
</code></pre>
<hr />
<h2 id="for-each-循环"><a class="header" href="#for-each-循环">For-Each 循环</a></h2>
<p>JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。</p>
<p>语法格式如下：</p>
<pre><code class="language-java">for(type element: array)
{
    System.out.println(element);
}
</code></pre>
<p>该实例用来显示数组 myList 中的所有元素：</p>
<pre><code class="language-java">public class TestArray {
   public static void main(String[] args) {
      double[] myList = {1.9, 2.9, 3.4, 3.5};
 
      // 打印所有数组元素
      for (double element: myList) {
         System.out.println(element);
      }
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>1.9
2.9
3.4
3.5
</code></pre>
<hr />
<h2 id="数组作为函数的参数"><a class="header" href="#数组作为函数的参数">数组作为函数的参数</a></h2>
<p>数组可以作为参数传递给方法。</p>
<p>例如，下面的例子就是一个打印 int 数组中元素的方法:</p>
<pre><code class="language-java">public static void printArray(int[] array) {
  for (int i = 0; i &lt; array.length; i++) {
    System.out.print(array[i] + &quot; &quot;);
  }
}
</code></pre>
<p>下面例子调用 printArray 方法打印出 3，1，2，6，4 和 2：</p>
<pre><code class="language-java">printArray(new int[]{3, 1, 2, 6, 4, 2});
</code></pre>
<hr />
<h2 id="数组作为函数的返回值"><a class="header" href="#数组作为函数的返回值">数组作为函数的返回值</a></h2>
<pre><code class="language-java">public static int[] reverse(int[] list) {
  int[] result = new int[list.length];
 
  for (int i = 0, j = result.length - 1; i &lt; list.length; i++, j--) {
    result[j] = list[i];
  }
  return result;
}
</code></pre>
<p>以上实例中 result 数组作为函数的返回值。</p>
<hr />
<h2 id="多维数组"><a class="header" href="#多维数组">多维数组</a></h2>
<p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，例如：</p>
<pre><code class="language-java">String[][] str = new String[3][4];
</code></pre>
<p>二维数组的声明形式有如下三种：<code>int[][] y;</code>、<code>int[] y[];</code>、<code>int y[][];</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202401151546762.png" alt="" /></p>
<p>这种赋值方式<code>String[] strs = new String[]{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};</code>也是允许的。</p>
<h3 id="多维数组的动态初始化以二维数组为例"><a class="header" href="#多维数组的动态初始化以二维数组为例">多维数组的动态初始化（以二维数组为例）</a></h3>
<ol>
<li>直接为每一维分配空间，格式如下：</li>
</ol>
<pre><code class="language-java">type[][] typeName = new type[typeLength1][typeLength2];
</code></pre>
<p>type 可以为基本数据类型和复合数据类型，typeLength1 和 typeLength2 必须为正整数，typeLength1 为行数，typeLength2 为列数。</p>
<p>例如：</p>
<pre><code class="language-java">int[][] a = new int[2][3];
</code></pre>
<p>解析：</p>
<p>二维数组 a 可以看成一个两行三列的数组。</p>
<ol start="2">
<li>从最高维开始，分别为每一维分配空间，例如：</li>
</ol>
<pre><code class="language-java">String[][] s = new String[2][];
s[0] = new String[2];
s[1] = new String[3];
s[0][0] = new String(&quot;Good&quot;);
s[0][1] = new String(&quot;Luck&quot;);
s[1][0] = new String(&quot;to&quot;);
s[1][1] = new String(&quot;you&quot;);
s[1][2] = new String(&quot;!&quot;);
</code></pre>
<p>解析：</p>
<p><strong><code>s[0]=new String[2]** 和 **s[1]=new String[3]</code></strong> 是为最高维分配引用空间，也就是为最高维限制其能保存数据的最长的长度，然后再为其每个数组元素单独分配空间 <strong>s0=new String(&quot;Good&quot;)</strong> 等操作。</p>
<p>实例：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[][] a = new int[2][3];
		int k = 1;
		for(int i = 0; i &lt; a.length; i++) {
			for(int j = 0; j &lt; a[i].length; j += 2) {
				a[i][j] = k++;
			}
		}
		for(int i = 0; i &lt; a.length; i++) {
			for(int j = 0; j &lt; a[i].length; j++) {
				System.out.print(a[i][j] + &quot; &quot;);
			}
			System.out.print('\n');
		}
		int[][] b = {{1}, {1,2,3}};
		for(int i = 0; i &lt; b.length; i++) {
			for(int j = 0; j &lt; b[i].length; j++) {
				System.out.print(b[i][j] + &quot; &quot;);
			}
			System.out.println();
		}
		int n = 10;
		int[][] c = new int[n][];
		for(int i = 0; i &lt; c.length; i++) {
			c[i] = new int[i + 1];
			for(int j = 0; j &lt; c[i].length; j++) {
				if(j == 0 || j == c[i].length - 1) {
					c[i][j] = 1;
				}else {
					c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
				}
			}
		}
		for(int i = 0; i &lt; c.length; i++) {
			for(int j = 0; j &lt; c[i].length; j++) {
				System.out.print(c[i][j] + &quot;\t&quot;);
			}
			System.out.println();
		}
	}
	
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>1 0 2 
3 0 4 
1 
1 2 3 
1	
1	1	
1	2	1	
1	3	3	1	
1	4	6	4	1	
1	5	10	10	5	1	
1	6	15	20	15	6	1	
1	7	21	35	35	21	7	1	
1	8	28	56	70	56	28	8	1	
1	9	36	84	126	126	84	36	9	1
</code></pre>
<p>注意：二维数组中可以省略部分元素</p>
<h3 id="多维数组的引用以二维数组为例"><a class="header" href="#多维数组的引用以二维数组为例">多维数组的引用（以二维数组为例）</a></h3>
<p>对二维数组中的每个元素，引用方式为 <strong><code>arrayName[index1][index2]</code></strong>，例如：</p>
<pre><code class="language-java">num[1][0];
</code></pre>
<hr />
<h2 id="arrays-类"><a class="header" href="#arrays-类">Arrays 类</a></h2>
<p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>具有以下功能：</p>
<ul>
<li>给数组赋值：通过 fill 方法。</li>
<li>对数组排序：通过 sort 方法,按升序。</li>
<li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li>
<li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li>
</ul>
<p>具体说明请查看下表：</p>
<div class="table-wrapper"><table><thead><tr><th>序号</th><th>方法和说明</th></tr></thead><tbody>
<tr><td>1</td><td><strong>public static int binarySearch(Object[] a, Object key)</strong>  <br>用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(<em>插入点</em>) - 1)。</td></tr>
<tr><td>2</td><td><strong>public static boolean equals(long[] a, long[] a2)</strong>  <br>如果两个指定的 long 型数组彼此_相等_，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td></tr>
<tr><td>3</td><td><strong>public static void fill(int[] a, int val)</strong>  <br>将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td></tr>
<tr><td>4</td><td><strong>public static void sort(Object[] a)</strong>  <br>对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="面向对象基础"><a class="header" href="#面向对象基础">面向对象基础</a></h1>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B">面向对象简介</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6">内存分配机制</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">成员方法</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8">方法的定义和调用</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html#%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9">方法的优点</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html#%E6%96%B9%E6%B3%95%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">方法的命名规则</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89">方法的定义</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">方法调用</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html#void-%E5%85%B3%E9%94%AE%E5%AD%97">void 关键字</a></li>
</ul>
</li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html#%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6">传参机制</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html#%E9%80%9A%E8%BF%87%E5%80%BC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0">通过值传递参数</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92">引用传递</a></li>
</ul>
</li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverload">方法重载（OverLoad）</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">可变参数</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F">变量作用域</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1">构造方法——初始化对象</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html#this%E5%85%B3%E9%94%AE%E5%AD%97">this关键字</a></li>
</ul>
</li>
</ul>
<h1 id="面向对象简介"><a class="header" href="#面向对象简介">面向对象简介</a></h1>
<p>成员变量也叫属性、字段。</p>
<p>面向对象编程Object-Oriented Programming</p>
<p>本质：<strong>以类的方式组织代码，以对象的方式组织（封装）数据</strong></p>
<p>核心方法：抽象</p>
<p>三大特性：封装、继承、多态</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202401241416915.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202401241425054.png" alt="" /></p>
<p><code>new Test().count();</code>表示调用匿名对象的count()方法。</p>
<h1 id="内存分配机制"><a class="header" href="#内存分配机制">内存分配机制</a></h1>
<p>对象内存布局如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202401171458372.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202401171522446.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202401171536116.png" alt="" /></p>
<p>实例：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Person p1 = new Person();
		p1.age = 10;
		p1.name = &quot;包子&quot;;
		Person p2 = new Person();
		p2 = p1;
		System.out.println(p2.age);
		p2.name = &quot;腊肉&quot;;
		System.out.println(p1.name);
		p2 = null;
		System.out.println(p1.name);
	}
}

class Person{
	int age;
	String name;
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>10
腊肉
腊肉
</code></pre>
<h1 id="成员方法"><a class="header" href="#成员方法">成员方法</a></h1>
<p>方法调用机制：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202401181450839.png" alt="" /></p>
<h2 id="方法的定义和调用"><a class="header" href="#方法的定义和调用">方法的定义和调用</a></h2>
<p>Java方法是语句的集合，它们在一起执行一个功能。</p>
<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>方法包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
<h3 id="方法的优点"><a class="header" href="#方法的优点">方法的优点</a></h3>
<ul>
<li>
<ol>
<li>使程序变得更简短而清晰。</li>
</ol>
</li>
<li>
<ol start="2">
<li>有利于程序维护。</li>
</ol>
</li>
<li>
<ol start="3">
<li>可以提高程序开发的效率。</li>
</ol>
</li>
<li>
<ol start="4">
<li>提高了代码的重用性。</li>
</ol>
</li>
</ul>
<h3 id="方法的命名规则"><a class="header" href="#方法的命名规则">方法的命名规则</a></h3>
<p>1.方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。例如：<strong>addPerson</strong>。</p>
<p>2.下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<strong><code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code></strong>，例如 <strong>testPop_emptyStack</strong>。</p>
<h3 id="方法的定义"><a class="header" href="#方法的定义">方法的定义</a></h3>
<p>一般情况下，定义一个方法包含以下语法：</p>
<pre><code class="language-java">修饰符 返回值类型 方法名(参数类型 参数名){
    ...
    方法体
    ...
    return 返回值;
}
</code></pre>
<p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>
<ul>
<li><strong>修饰符：</strong> 修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li>
<li><strong>返回值类型 ：</strong> 方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字<strong>void</strong>。</li>
<li><strong>方法名：</strong> 是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li><strong>参数类型：</strong> 参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li>
<li><strong>方法体：</strong> 方法体包含具体的语句，定义该方法的功能。</li>
</ul>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/D53C92B3-9643-4871-8A72-33D491299653.jpg" alt="img" /></p>
<p><strong>注意：</strong> 在一些其它语言中方法指过程和函数。一个返回非void类型返回值的方法称为函数；一个返回void类型返回值的方法叫做过程。</p>
<p>实例：下面的方法包含 2 个参数 num1 和 num2，它返回这两个参数的最大值。</p>
<pre><code class="language-java">/** 返回两个整型变量数据的较大值 */
public static int max(int num1, int num2) {
   int result;
   if (num1 &gt; num2)
      result = num1;
   else
      result = num2;
 
   return result; 
}
</code></pre>
<p>更简略的写法（三元运算符）：</p>
<pre><code class="language-java">public static int max(int num1, int num2) {
  return num1 &gt; num2 ? num1 : num2;
}
</code></pre>
<h3 id="方法调用"><a class="header" href="#方法调用">方法调用</a></h3>
<p>Java 支持两种调用方法的方式，根据方法是否返回值来选择。</p>
<p>当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。</p>
<p>当方法返回一个值的时候，方法调用通常被当做一个值。例如：</p>
<pre><code class="language-java">int larger = max(30, 40);
</code></pre>
<p>如果方法返回值是void，方法调用一定是一条语句。例如，方法println返回void。下面的调用是个语句：</p>
<pre><code class="language-java">System.out.println(&quot;欢迎访问菜鸟教程！&quot;);
</code></pre>
<p>实例：下面的例子演示了如何定义一个方法，以及如何调用它。</p>
<pre><code class="language-java">public class TestMax {
   /** 主方法 */
   public static void main(String[] args) {
      int i = 5;
      int j = 2;
      int k = max(i, j);
      System.out.println( i + &quot; 和 &quot; + j + &quot; 比较，最大值是：&quot; + k);
   }
 
   /** 返回两个整数变量较大的值 */
   public static int max(int num1, int num2) {
      int result;
      if (num1 &gt; num2)
         result = num1;
      else
         result = num2;
 
      return result; 
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>5 和 2 比较，最大值是：5
</code></pre>
<p>这个程序包含 main 方法和 max 方法。main 方法是被 JVM 调用的，除此之外，main 方法和其它方法没什么区别。</p>
<p>main 方法的头部是不变的，如例子所示，带修饰符 public 和 static,返回 void 类型值，方法名字是 main,此外带个一个 <code>String[]</code> 类型参数。<code>String[]</code> 表明参数是字符串数组。</p>
<h3 id="void-关键字"><a class="header" href="#void-关键字">void 关键字</a></h3>
<p>本节说明如何声明和调用一个 void 方法。</p>
<p>下面的例子声明了一个名为 printGrade 的方法，并且调用它来打印给定的分数。</p>
<pre><code class="language-java">public class TestVoidMethod {
  public static void main(String[] args) {
    printGrade(78.5);
  }
 
  public static void printGrade(double score) {
    if (score &gt;= 90.0) {
       System.out.println('A');
    }
    else if (score &gt;= 80.0) {
       System.out.println('B');
    }
    else if (score &gt;= 70.0) {
       System.out.println('C');
    }
    else if (score &gt;= 60.0) {
       System.out.println('D');
    }
    else {
       System.out.println('F');
    }
  }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>C
</code></pre>
<p>这里printGrade方法是一个void类型方法，它不返回值。</p>
<p>一个void方法的调用一定是一个语句。 所以，它被在main方法第三行以语句形式调用。就像任何以分号结束的语句一样。</p>
<h2 id="传参机制"><a class="header" href="#传参机制">传参机制</a></h2>
<p><code>值传递</code>（pass by value）是指在调用函数时将实际参数 <code>复制</code> 一份传递到函数中,而并不是将这个值直接传递给函数</p>
<p><code>引用传递</code>（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，而传递过来的地址还是与之前的地址指向同一个值，那么要是修改了这个参数，就会影响这个值的改变</p>
<h3 id="通过值传递参数"><a class="header" href="#通过值传递参数">通过值传递参数</a></h3>
<p>调用一个方法时候需要提供参数，你必须<strong>按照参数列表指定的顺序</strong>提供提供参数。</p>
<p>例如，下面的方法连续n次打印一个消息：</p>
<pre><code class="language-java">public static void nPrintln(String message, int n) {
  for (int i = 0; i &lt; n; i++) {
    System.out.println(message);
  }
}
</code></pre>
<p>下面的例子演示按值传递的效果。该程序创建一个方法，该方法用于交换两个变量。</p>
<pre><code class="language-java">public class TestPassByValue {
  public static void main(String[] args) {
    int num1 = 1;
    int num2 = 2;
 
    System.out.println(&quot;交换前 num1 的值为：&quot; +
                        num1 + &quot; ，num2 的值为：&quot; + num2);
 
    // 调用swap方法
    swap(num1, num2);
    System.out.println(&quot;交换后 num1 的值为：&quot; +
                       num1 + &quot; ，num2 的值为：&quot; + num2);
  }
  /** 交换两个变量的方法 */
  public static void swap(int n1, int n2) {
    System.out.println(&quot;\t进入 swap 方法&quot;);
    System.out.println(&quot;\t\t交换前 n1 的值为：&quot; + n1
                         + &quot;，n2 的值：&quot; + n2);
    // 交换 n1 与 n2的值
    int temp = n1;
    n1 = n2;
    n2 = temp;
 
    System.out.println(&quot;\t\t交换后 n1 的值为 &quot; + n1
                         + &quot;，n2 的值：&quot; + n2);
  }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>交换前 num1 的值为：1 ，num2 的值为：2
    进入 swap 方法
        交换前 n1 的值为：1，n2 的值：2
        交换后 n1 的值为 2，n2 的值：1
交换后 num1 的值为：1 ，num2 的值为：2
</code></pre>
<p>传递两个参数调用swap方法。<strong>有趣的是，方法被调用后，实参的值并没有改变。</strong></p>
<p>传递字符串类型变量也是值传递方式。</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		String num1 = &quot;我爱吃大包子！&quot;;
	    String num2 = &quot;你是老腊肉！&quot;;
	 
	    System.out.println(&quot;交换前 num1 的值为：&quot; +
	                        num1 + &quot; ，num2 的值为：&quot; + num2);
	 
	    // 调用swap方法
	    swap(num1, num2);
	    System.out.println(&quot;交换后 num1 的值为：&quot; +
	                       num1 + &quot; ，num2 的值为：&quot; + num2);
	  }
	  /** 交换两个变量的方法 */
	 public static void swap(String n1, String n2) {
	    System.out.println(&quot;\t进入 swap 方法&quot;);
	    System.out.println(&quot;\t\t交换前 n1 的值为：&quot; + n1
	                         + &quot;，n2 的值：&quot; + n2);
	    // 交换 n1 与 n2的值
	    String temp = n1;
	    n1 = n2;
	    n2 = temp;
	 
	    System.out.println(&quot;\t\t交换后 n1 的值为 &quot; + n1
	                         + &quot;，n2 的值：&quot; + n2);
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>交换前 num1 的值为：我爱吃大包子！ ，num2 的值为：你是老腊肉！
	进入 swap 方法
		交换前 n1 的值为：我爱吃大包子！，n2 的值：你是老腊肉！
		交换后 n1 的值为 你是老腊肉！，n2 的值：我爱吃大包子！
交换后 num1 的值为：我爱吃大包子！ ，num2 的值为：你是老腊肉！
</code></pre>
<p>更改swap()函数位置，输出结果不变</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		String num1 = &quot;我爱吃大包子！&quot;;
	    String num2 = &quot;你是老腊肉！&quot;;
	 
	    System.out.println(&quot;交换前 num1 的值为：&quot; +
	                        num1 + &quot; ，num2 的值为：&quot; + num2);
	 
	    // 调用swap方法
	    B b = new B();
	    b.swap(num1, num2);
	    System.out.println(&quot;交换后 num1 的值为：&quot; +
	                       num1 + &quot; ，num2 的值为：&quot; + num2);
	  }
}

class B{
	/** 交换两个变量的方法 */
	public static void swap(String n1, String n2) {
	    System.out.println(&quot;\t进入 swap 方法&quot;);
	    System.out.println(&quot;\t\t交换前 n1 的值为：&quot; + n1
	                         + &quot;，n2 的值：&quot; + n2);
	    // 交换 n1 与 n2的值
	    String temp = n1;
	    n1 = n2;
	    n2 = temp;
	 
	    System.out.println(&quot;\t\t交换后 n1 的值为 &quot; + n1
	                         + &quot;，n2 的值：&quot; + n2);
	}
}
</code></pre>
<h3 id="引用传递"><a class="header" href="#引用传递">引用传递</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202401181621556.png" alt="" /></p>
<p>方法接收数组并修改数组，能改变原来的数组，如下例所示：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] arr = {1, 2, 3};
		System.out.println(&quot;原数组&quot;);
		for(int i = 0; i &lt; arr.length; i++) {
	    	System.out.print(arr[i] + &quot;\t&quot;);
	    }
		System.out.println();
	    // 调用swap方法
	    B b = new B();
	    b.test100(arr);
	    System.out.println();
	    System.out.println(&quot; main的 arr数组 &quot;);
	    for(int i = 0; i &lt; arr.length; i++) {
	    	System.out.print(arr[i] + &quot;\t&quot;);
	    }
	    System.out.println();
	}
}

class B{
	/** 交换两个变量的方法 */
	public void test100(int[] arr) {
	    arr[0] = 200;
	    System.out.println(&quot; test100的 arr数组 &quot;);
	    for(int i = 0; i &lt; arr.length; i++) {
	    	System.out.print(arr[i] + &quot;\t&quot;);
	    }
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>原数组
1	2	3	
 test100的 arr数组 
200	2	3	
 main的 arr数组 
200	2	3
</code></pre>
<p>以对象为参数时也是引用传递。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202401191448016.png" alt="" /></p>
<p>如下例所示：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Person p = new Person();
		p.name = &quot;jack&quot;;
		p.age = 10;
	    B b = new B();
	    b.test200(p);
	    System.out.println(&quot;main的p.age=&quot; + p.age);
	}
}

class Person{
	String name;
	int age;
}

class B{
	public void test200(Person p) {
	    p.age = 20000;
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>main的p.age=20000
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202401191453442.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202401191458418.png" alt="" />
实例：老鼠走迷宫</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[][] map = new int[8][7];
		//地图上点的值为1则不能走，是0则可以走
		for(int i = 0; i &lt; map[i].length; i++) {
			map[0][i] = 1;
			map[7][i] = 1;
		}
		for(int i = 0; i &lt; map.length; i++) {
			map[i][0] = 1;
			map[i][6] = 1;
		}
		map[3][1] = 1;
		map[3][2] = 1;
		for(int i = 0; i &lt; map.length; i++) {
			for(int j = 0; j &lt; map[i].length; j++) {
				System.out.print(map[i][j] + &quot; &quot;);
			}
			System.out.println();
		}
		System.out.println(&quot;=====Go!=====&quot;);
		Ways way = new Ways();
		way.findways(map, 1, 1);
		for(int i = 0; i &lt; map.length; i++) {
			for(int j = 0; j &lt; map[i].length; j++) {
				System.out.print(map[i][j] + &quot; &quot;);
			}
			System.out.println();
		}
	}
}

class Ways{
	public boolean findways(int[][] map, int i, int j) {
	//地图上点的值为1则不能走，是0则可以走，为2则能到达终点，为3则不能到达终点
	//寻路策略是先下再右再上最后左
		if(map[6][5] == 2) {
			return true;
		}else {
			if(map[i][j] == 0) {
				map[i][j] = 2;
				if(findways(map, i + 1, j)) {
					return true;
				}else if(findways(map, i, j + 1)) {
					return true;
				}else if(findways(map, i - 1, j)) {
					return true;
				}else if(findways(map, i, j - 1)) {
					return true;
				}else {
					map[i][j] = 3;
					return false;
				}
			}else {
				return false;
			}
		}
	}
}

</code></pre>
<p>输出结果如下：</p>
<pre><code>1 1 1 1 1 1 1 
1 0 0 0 0 0 1 
1 0 0 0 0 0 1 
1 1 1 0 0 0 1 
1 0 0 0 0 0 1 
1 0 0 0 0 0 1 
1 0 0 0 0 0 1 
1 1 1 1 1 1 1 
=====Go!=====
1 1 1 1 1 1 1 
1 2 0 0 0 0 1 
1 2 2 2 0 0 1 
1 1 1 2 0 0 1 
1 0 0 2 0 0 1 
1 0 0 2 0 0 1 
1 0 0 2 2 2 1 
1 1 1 1 1 1 1 
</code></pre>
<h2 id="方法重载overload"><a class="header" href="#方法重载overload">方法重载（OverLoad）</a></h2>
<p>方法重载：同一个类中方法名字相同，而形式参数不同</p>
<p>原理：编译器逐个匹配</p>
<p>原则：</p>
<ul>
<li><strong>方法名必须相同</strong></li>
<li><strong>形参列表必须不同，如个数不同，类型不同，参数排列顺序不同等，但和形参名称无关</strong></li>
<li><strong>方法的返回类型可以相同也可以不同</strong></li>
<li><strong>仅仅返回类型不同不足以称为方法重载</strong></li>
</ul>
<p>上面使用的max方法仅仅适用于int型数据。但如果你想得到两个浮点类型数据的最大值呢？</p>
<p>解决方法是创建另一个有相同名字但参数不同的方法，如下面代码所示：</p>
<pre><code class="language-java">public static double max(double num1, double num2) 
{  
	if (num1 &gt; num2)    
		return num1;  
	else    
		return num2; 
}
</code></pre>
<p>如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；</p>
<p>如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；</p>
<p>就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。</p>
<p>Java编译器根据方法签名判断哪个方法应该被调用。</p>
<p>方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。</p>
<p>重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。</p>
<h2 id="可变参数"><a class="header" href="#可变参数">可变参数</a></h2>
<p>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。java允许将<strong>同一个类中多个同名同功能但参数个数不同</strong>的方法，封装成一个方法。</p>
<p>基本语法：</p>
<pre><code class="language-java">访问修饰符 返回类型 方法名(数据类型...形参名){

}
</code></pre>
<p>方法的可变参数的声明如下所示：</p>
<p><code>typeName... parameterName</code></p>
<p>在方法声明中，在指定参数类型后加一个省略号(...) 。</p>
<p>==一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。==</p>
<p>实例：</p>
<pre><code class="language-java">public class helloworld {
    public static void main(String args[]) {
        // 调用可变参数的方法
        printMax(34, 3, 3, 2, 56.5);
        printMax(new double[]{1, 2, 3});
    }
 
    public static void printMax( double... numbers) {
        if (numbers.length == 0) {
            System.out.println(&quot;No argument passed&quot;);
            return;
        }
 
        double result = numbers[0];
 
        for (int i = 1; i &lt;  numbers.length; i++){
            if (numbers[i] &gt;  result) {
                result = numbers[i];
            }
        }
        System.out.println(&quot;The max value is &quot; + result);
    }
}

</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>The max value is 56.5
The max value is 3.0
</code></pre>
<p>注意：上面程序中numbers被当成数组使用。</p>
<h2 id="变量作用域"><a class="header" href="#变量作用域">变量作用域</a></h2>
<p>变量的范围是程序中该变量可以被引用的部分。</p>
<p>方法内定义的变量被称为局部变量。局部变量的作用范围从声明开始，直到包含它的块结束。局部变量必须声明才可以使用。</p>
<p>方法的参数范围涵盖整个方法。参数实际上是一个局部变量。</p>
<p>for循环的初始化部分声明的变量，其作用范围在整个循环。</p>
<p>但循环体内声明的变量其适用范围是从它声明到循环体结束。它包含如下所示的变量声明：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/12-130Q1221013F0.jpg" alt="img" /></p>
<p>你可以在一个方法里，不同的非嵌套块中多次声明一个具有相同的名称局部变量，但你不能在嵌套块内两次声明局部变量。</p>
<p>==全局变量（属性）可以不赋值，直接使用，因为有默认值。==</p>
<p>==局部变量必须赋值才能使用，因为没有默认值。==</p>
<p>实例：</p>
<pre><code class="language-java">public class helloworld {
    public static void main(String args[]) {
        Cat cat = new Cat();
        cat.Print();//输出0.0
    }
}
class Cat{
	double weight;
	public  void Print() {
		System.out.println(weight);
	}
}
</code></pre>
<p>下面的代码会报错<code>The local variable weight may not have been initialized</code>：</p>
<pre><code class="language-java">public class helloworld {
    public static void main(String args[]) {
        Cat cat = new Cat();
        cat.Print();
    }
}
class Cat{
	
	public  void Print() {
		double weight;
		System.out.println(weight);
	}
}
</code></pre>
<p>1.属性和局部变量可以重名，访问时遵循就近原则</p>
<p>2.在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名。</p>
<p>3.属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而释放，即在一次方法调用过程中生效。</p>
<p>实例：</p>
<pre><code class="language-java">public class helloworld {
    public static void main(String args[]) {
        Cat cat = new Cat();
        cat.Print();
    }
}
class Cat{
	String name = &quot;baozi&quot;;
	public  void Print() {
		String name = &quot;Jack&quot;;
		System.out.println(&quot;name = &quot; + name);
	}
}
</code></pre>
<p>输出结果如下：<code>name = Jack</code></p>
<p>4.作用域范围不同</p>
<p>全局变量/属性：可以被本类使用，或其他类使用（通过对象调用）</p>
<p>局部变量：只能在本类中对应的方法中使用</p>
<p>5.修饰符不同</p>
<p>全局变量/属性可以加修饰符</p>
<p>局部变量不可以加修饰符，但局部变量前可以加final，但final不是数据类型。例如<code>final String name = &quot;Jack&quot;;</code>能够通过编译。</p>
<p>实例：</p>
<pre><code class="language-java">public class helloworld {
    public static void main(String args[]) {
        T t = new T();
        t.test2();
    }
}

class T{
	public void test(Cat cat) {
		System.out.println(cat.name);
	}
	public void test2() {
		Cat cat = new Cat();
		System.out.println(cat.name);
	}
}

class Cat{
	String name = &quot;baozi&quot;;
	public  void Print() {
		String name = &quot;Jack&quot;;
		System.out.println(&quot;name = &quot; + name);
	}
}
</code></pre>
<p>输出<code>baozi</code></p>
<h2 id="构造方法初始化对象"><a class="header" href="#构造方法初始化对象">构造方法——初始化对象</a></h2>
<p>当一个对象被创建时，构造方法用来<strong>初始化</strong>该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。</p>
<p>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。</p>
<p><strong>不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同(类为public，构造函数也为public；类改为 protected，构造函数也改为protected)。</strong></p>
<p>一旦你定义了自己的构造方法，默认构造方法就会失效。大多时候需要一个有参数的构造方法。</p>
<p>下面是一个使用构造方法的例子：</p>
<pre><code class="language-java">// 一个简单的构造函数
class MyClass {
  int x;
 
  // 以下是构造函数
  MyClass(int i ) {
    x = i;
  }
}
</code></pre>
<p>你可以像下面这样调用构造方法来初始化一个对象：</p>
<pre><code class="language-java">public class ConsDemo {
  public static void main(String args[]) {
    MyClass t1 = new MyClass( 10 );
    MyClass t2 = new MyClass( 20 );
    System.out.println(t1.x + &quot; &quot; + t2.x);
  }
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>10 20
</code></pre>
<p>构造器细节：</p>
<p>1.一个类可以定义多个不同的构造器，即构造器重载</p>
<p>比如：我们可以再给Person类定义一个构造器，用来创建对象的时候，只指定人名，不需要指定年龄</p>
<p>2.构造器名和类名要相同</p>
<p>3.构造器没有返回值</p>
<p>4.构造器是完成对象的初始化，并不是创建对象</p>
<p>5.在创建对象时，系统自动的调用该类的构造方法</p>
<p>6.如果程序员没有定义构造方法，系统会自动给类生成一个默认无参构造方法（也叫默认构造方法），可以使用javap指令反编译看看，例如执行<code>javap Dog.class</code>或<code>javap -c -v Dog</code>。</p>
<p>7.一旦定义了自己的构造器，默认的构造器就被覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下</p>
<h2 id="this关键字"><a class="header" href="#this关键字">this关键字</a></h2>
<p>Java虚拟机给每个对象分配this，指代当前对象</p>
<pre><code class="language-java">public class helloworld {
    public static void main(String args[]) {
        T t = new T();
        t.test2();
        System.out.println(&quot;t对象的hashcode为&quot; + t.hashCode());
    }
}

class T{
	public void test(Cat cat) {
		System.out.println(cat.name);
	}
	public void test2() {
		Cat cat = new Cat();
		System.out.println(cat.name);
	}
}

class Cat{
	String name;
	public Cat() {
		this(&quot;jack ma&quot;);
	}
	public Cat(String name) {
		// TODO Auto-generated constructor stub
		this.name = name;
		System.out.println(&quot;构造器被调用~~~&quot;);
		this.Print();
	}
	public  void Print() {
		final String name = &quot;Jack&quot;;
		System.out.println(&quot;name = &quot; + name);
		System.out.println(&quot;this对象的hashcode为&quot; + this.hashCode());
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>构造器被调用~~~
name = Jack
this对象的hashcode为1134712904
jack ma
t对象的hashcode为968514068
</code></pre>
<p>使用this的细节：</p>
<p>1.this关键字可以用来访问本类的属性、方法、构造器</p>
<p>2.this用于区分当前类的属性和局部变量</p>
<p>3.访问成员方法的语法：this.方法名（参数列表）</p>
<p>4.访问构造器语法：this（参数列表）；注意只能在构造器中使用，而且<code>Constructor call must be the first statement in a constructor</code></p>
<p>5.this不能在类定义的外部使用，只能在类定义的方法中使用</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="面向对象进阶"><a class="header" href="#面向对象进阶">面向对象进阶</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
